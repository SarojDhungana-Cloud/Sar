<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Summary – Custom Dashboard</title>

<!-- Plotly + DataTables + jQuery (CDN) -->
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<link rel="stylesheet" href="https://cdn.datatables.net/2.0.5/css/dataTables.dataTables.min.css"/>
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.datatables.net/2.0.5/js/dataTables.min.js"></script>

<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans; margin: 20px; }
  .grid { display: grid; grid-template-columns: repeat(6, minmax(160px, 1fr)); gap: 12px; }
  .card { background: #fff; border: 1px solid #eaecef; border-radius: 12px; padding: 16px; margin-bottom: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.04); }
  label { font-size: 12px; color: #555; display:block; margin-bottom:6px; }
  input[type="date"], select { width: 100%; padding: 8px 10px; border:1px solid #dfe3e8; border-radius:8px; }
  button.primary { padding: 10px 14px; border: 0; border-radius: 10px; background: #2563eb; color: white; font-weight: 600; cursor: pointer; }
  button.primary:hover { background: #1d4ed8; }
  .chart { height: 480px; position: relative; }
  .toolbar { position:absolute; top:8px; right:8px; display:flex; gap:8px; z-index:5; }
  .toolbtn { background:#0f172a; color:#fff; border:0; border-radius:8px; padding:6px 10px; cursor:pointer; font-size:12px; opacity:.9 }
  .toolbtn:hover { opacity:1 }
  .note { font-size: 12px; color: #666; white-space:pre-wrap; }
  .row { display:flex; align-items:center; gap:16px; flex-wrap:wrap; }
  .inline { display:flex; align-items:center; gap:8px; }

  /* Data Levels panel (visibility + value labels) */
  .panel { position:absolute; top:40px; right:8px; z-index:6; background:#ffffff; border:1px solid #e5e7eb; border-radius:10px; padding:10px; width:260px; box-shadow: 0 8px 24px rgba(0,0,0,.08); display:none; }
  .panel h4 { margin:0 0 8px 0; font-size:13px; }
  .trace-list { max-height:160px; overflow:auto; border:1px solid #f1f5f9; border-radius:8px; padding:6px; margin:6px 0 10px; }
  .panel .inline { justify-content: space-between; }

  /* Download button near table */
  .table-actions { display:flex; align-items:center; gap:12px; margin-bottom:8px; }
  .btn-lite { padding:8px 12px; border:1px solid #cbd5e1; background:#fff; border-radius:8px; cursor:pointer; }
  .btn-lite:hover { background:#f8fafc; }
</style>
</head>
<body>

<div class="card">
  <h1 style="margin:0 0 12px 0;">Summary – Custom Dashboard</h1>
  <div class="note">Data source: <code id="csvUrl"></code></div>
</div>

<div class="card">
  <h2 style="margin:0 8px 12px 0;">Filters</h2>
  <div class="row" style="margin-bottom:10px;">
    <div class="inline">
      <input type="radio" id="modeAD" name="dateMode" value="AD" checked>
      <label for="modeAD"><b>Use DATE (AD)</b></label>
    </div>
    <div class="inline">
      <input type="radio" id="modeBS" name="dateMode" value="BS" disabled>
      <label for="modeBS"><b>Use Nepali_Date (BS)</b></label>
    </div>
    <span class="note" id="nepAvail"></span>
  </div>

  <div class="grid" id="adControls">
    <div>
      <label>First_Date (AD)</label>
      <input type="date" id="firstDateAD" />
    </div>
    <div>
      <label>Second_Date (AD)</label>
      <input type="date" id="secondDateAD" />
    </div>
  </div>

  <div class="grid" id="bsControls" style="display:none;">
    <div>
      <label>First_Nepali_Date (BS)</label>
      <select id="firstDateBS"></select>
    </div>
    <div>
      <label>Second_Nepali_Date (BS)</label>
      <select id="secondDateBS"></select>
    </div>
  </div>

  <div class="grid" style="margin-top:10px;">
    <div>
      <label>Day_Name</label>
      <select id="dayName"></select>
    </div>
    <div>
      <label>Type</label>
      <select id="typeSel"></select>
    </div>
    <div>
      <label>Block1</label>
      <select id="blockStart"></select>
    </div>
    <div>
      <label>Blockn</label>
      <select id="blockEnd"></select>
    </div>
  </div>

  <div style="margin-top:14px;">
    <button id="generateBtn" class="primary">Generate</button>
    <span class="note" id="rowCount" style="margin-left:12px;"></span>
  </div>
</div>

<!-- CHART 1 -->
<div class="card">
  <h2 style="margin:0 0 12px 0;">Chart 1 — Block-wise average price plot within the specified range of days</h2>
  <div id="chart" class="chart">
    <div class="toolbar">
      <button class="toolbtn" onclick="togglePanel('chart')">⚙️ Data levels</button>
      <button class="toolbtn" onclick="fs('chart')">⤢ Fullscreen</button>
    </div>
    <div id="panel-chart" class="panel">
      <h4>Series visibility</h4>
      <div id="traces-chart" class="trace-list"></div>
      <div class="inline">
        <label for="vals-chart">Show values</label>
        <input id="vals-chart" type="checkbox">
      </div>
    </div>
  </div>
  <div id="forecastNotes" class="note" style="margin-top:10px;"></div>
</div>

<!-- DATA TABLE -->
<div class="card">
  <div class="table-actions">
    <h2 style="margin:0;">Data</h2>
    <button id="downloadCsvBtn" class="btn-lite" title="Download current table as CSV">⬇️ Download CSV</button>
  </div>
  <div id="tableWrap"></div>
</div>

<!-- CHART 2 (below table) -->
<div class="card" id="card2" style="display:none;">
  <h2 style="margin:0 0 12px 0;">Chart 2 — Day-series (block-averaged)</h2>
  <div id="chart2" class="chart">
    <div class="toolbar">
      <button class="toolbtn" onclick="togglePanel('chart2')">⚙️ Data levels</button>
      <button class="toolbtn" onclick="fs('chart2')">⤢ Fullscreen</button>
    </div>
    <div id="panel-chart2" class="panel">
      <h4>Series visibility</h4>
      <div id="traces-chart2" class="trace-list"></div>
      <div class="inline">
        <label for="vals-chart2">Show values</label>
        <input id="vals-chart2" type="checkbox">
      </div>
      <div id="vals-note-chart2" class="note" style="margin-top:6px;">(Only effective when points &lt; 100)</div>
    </div>
  </div>
</div>

<!-- CHART 3 (below table) -->
<div class="card" id="card3" style="display:none;">
  <h2 id="chart3Title" style="margin:0 0 12px 0;">Chart 3 — Weekday averages (Sun→Sat)</h2>
  <div id="chart3" class="chart">
    <div class="toolbar">
      <button class="toolbtn" onclick="togglePanel('chart3')">⚙️ Data levels</button>
      <button class="toolbtn" onclick="fs('chart3')">⤢ Fullscreen</button>
    </div>
    <div id="panel-chart3" class="panel">
      <h4>Series visibility</h4>
      <div id="traces-chart3" class="trace-list"></div>
      <div class="inline">
        <label for="vals-chart3">Show values</label>
        <input id="vals-chart3" type="checkbox">
      </div>
    </div>
  </div>
</div>

<script>
/* ======= Fullscreen & Panel helpers ======= */
function fs(id){
  const el = document.getElementById(id);
  if (!document.fullscreenElement) { el.requestFullscreen?.(); }
  else { document.exitFullscreen?.(); }
}
function togglePanel(chartId){
  const el = document.getElementById('panel-'+chartId);
  el.style.display = (el.style.display==='none' || !el.style.display) ? 'block' : 'none';
}

/* ========= CSV loader (Supabase Storage) ========= */
const SUPABASE_BASE = "https://imloololrtufqywapowk.supabase.co/storage/v1/object/public/flat-data/summary";
const urlParams = new URLSearchParams(location.search);
const archiveDate = urlParams.get("date"); // YYYY-MM-DD
const CSV_URL = archiveDate ? `${SUPABASE_BASE}/archive/${archiveDate}.csv`
                            : `${SUPABASE_BASE}/latest/summary.csv`;
document.getElementById("csvUrl").textContent = CSV_URL;

/* tiny CSV parser */
function parseCSV(text) {
  const lines = text.replace(/\r/g,"").trim().split("\n");
  const headers = lines[0].split(",");
  const rows = lines.slice(1).map(line => {
    const parts = line.split(",");
    const obj = {};
    headers.forEach((h,i)=>obj[h]=parts[i]??"");
    return obj;
  });
  return { headers, rows };
}
function looksLikeBlock(h) { return /^\d{2}:\d{2}\s*-\s*\d{2}:\d{2}$/.test(h); }

/* ======= Utils ======= */
function todayISO(){ return new Date().toISOString().slice(0,10); }
function addDaysISO(iso, n){ const d=new Date(iso+"T00:00:00"); d.setDate(d.getDate()+n); return d.toISOString().slice(0,10); }
function* isoRange(lo, hi){
  let d = new Date(lo+"T00:00:00"); const end = new Date(hi+"T00:00:00");
  while (d <= end){ yield d.toISOString().slice(0,10); d.setDate(d.getDate()+1); }
}
function toCSV(rows, headers){
  const lines = [];
  lines.push(headers.join(","));
  rows.forEach(r=>{
    lines.push(headers.map(h => (r[h] ?? r[h] === 0) ? String(r[h]).replace(/,/g,"") : "").join(","));
  });
  return lines.join("\n");
}

async function loadPayload() {
  const resp = await fetch(CSV_URL, { cache: "no-store" });
  if (!resp.ok) throw new Error("Failed to load CSV: "+resp.status);
  const csv = await resp.text();
  const { headers, rows } = parseCSV(csv);

  const DATE="DATE", DAY="DAY_NAME", TYPE="TYPE", NEP="NEPALI_DATE";
  const blockCols = headers.filter(looksLikeBlock);

  const transformed = rows.map(r => {
    const o = { _DATE:r[DATE], _DAY:r[DAY], _TYPE:r[TYPE], _NEP:r[NEP] };
    blockCols.forEach(b => o[b] = r[b]==="" ? "" : Number(r[b]));
    return o;
  });

  const days = Array.from(new Set(transformed.map(r => r._DAY).filter(Boolean))).sort();
  const typesPresent = new Set(transformed.map(r => String(r._TYPE||"").toUpperCase()));
  const typeOptions = ["All"].concat(["DAM","RTM"].filter(t => typesPresent.has(t)));
  const dayOptions  = ["All"].concat(days);

  const adDates = transformed.map(r => r._DATE).filter(Boolean).sort();
  const dmin = adDates[0] || ""; const dmax = adDates[adDates.length-1] || "";
  const nepDates = Array.from(new Set(transformed.map(r => r._NEP).filter(Boolean))).sort();

  return {
    rows: transformed,
    block_cols: blockCols,
    has_nepali: true,
    nep_col: "_NEP",
    nep_dates: nepDates,
    default_nep_first: nepDates[0] || "",
    default_nep_second: nepDates[nepDates.length-1] || "",
    day_options: dayOptions,
    type_options: typeOptions,
    default_first_ad: dmin,
    default_second_ad: dmax,
    csv_url: CSV_URL,
    default_block1: "00:00-00:15",
    default_blockn: "23:45-24:00",
    col_names: { DATE_AD:"_DATE", DAY:"_DAY", TYPE:"_TYPE", NEPALI: "_NEP" }
  };
}

/* ========= Dashboard + Forecast + Extra Charts ========= */
(async function () {
  const payload = await loadPayload();
  const rows = payload.rows;
  const blocks = payload.block_cols.slice();
  const hasNepali = payload.has_nepali;
  const NEP_COL = payload.nep_col || "";
  const nepDates = payload.nep_dates || [];
  const DATE = payload.col_names["DATE_AD"];
  const DAY  = payload.col_names["DAY"];
  const TYPE = payload.col_names["TYPE"];
  const NEP  = payload.col_names["NEPALI"];

  // controls
  const modeAD  = document.getElementById('modeAD');
  const modeBS  = document.getElementById('modeBS');
  const adWrap  = document.getElementById('adControls');
  const bsWrap  = document.getElementById('bsControls');
  const fAD     = document.getElementById('firstDateAD');
  const sAD     = document.getElementById('secondDateAD');
  const fBS     = document.getElementById('firstDateBS');
  const sBS     = document.getElementById('secondDateBS');
  const daySel  = document.getElementById('dayName');
  const typeSel = document.getElementById('typeSel');
  const b1Sel   = document.getElementById('blockStart');
  const bnSel   = document.getElementById('blockEnd');

  if (hasNepali && NEP_COL) { modeBS.disabled = false; document.getElementById('nepAvail').textContent = ""; }
  else { modeBS.disabled = true; document.getElementById('nepAvail').textContent = "(Nepali_Date not found in CSV)"; }

  fAD.value = payload.default_first_ad || "";
  sAD.value = payload.default_second_ad || "";

  function populateBS(selectEl, values) {
    selectEl.innerHTML = "";
    values.forEach(v => {
      const o = document.createElement('option'); o.value = v; o.textContent = v; selectEl.appendChild(o);
    });
  }
  populateBS(fBS, nepDates);
  populateBS(sBS, nepDates);
  if (nepDates.length) { fBS.value = payload.default_nep_first || nepDates[0]; sBS.value = payload.default_nep_second || nepDates[nepDates.length-1]; }

  function refreshMode(){ adWrap.style.display = modeAD.checked ? "" : "none"; bsWrap.style.display = modeAD.checked ? "none" : ""; }
  modeAD.addEventListener('change', refreshMode);
  modeBS.addEventListener('change', refreshMode);
  refreshMode();

  (payload.day_options || ["All"]).forEach(v => { const o = document.createElement('option'); o.value=v; o.textContent=v; daySel.appendChild(o); });
  (payload.type_options || ["All","DAM","RTM"]).forEach(v => { const o = document.createElement('option'); o.value=v; o.textContent=v; typeSel.appendChild(o); });
  blocks.forEach(v => { const o1=document.createElement('option'); o1.value=v; o1.textContent=v; b1Sel.appendChild(o1);
                        const o2=document.createElement('option'); o2.value=v; o2.textContent=v; bnSel.appendChild(o2); });
  daySel.value="All"; typeSel.value="All";
  b1Sel.value = payload.default_block1 || blocks[0];
  bnSel.value = payload.default_blockn || blocks[blocks.length-1];

  function num(v){ if (v===null || v===undefined || v==="") return null; const n = Number(String(v).replace(/[, ]/g,'')); return Number.isFinite(n)? n : null; }

  // filters
  function filterRowsBase() {
    const useBS = modeBS.checked && hasNepali && NEP_COL;
    const dateField = useBS ? NEP_COL : DATE;
    const lo = (useBS ? fBS.value : fAD.value) || "";
    const hi = (useBS ? sBS.value : sAD.value) || "";
    const day = (daySel.value||"All").toLowerCase();
    const typ = (typeSel.value||"All").toUpperCase();

    const filtered = rows.filter(r => {
      const d = (r[dateField]||"").trim();
      const dn = (r[DAY]||"").trim().toLowerCase();
      const tp = (r[TYPE]||"").toUpperCase();
      if (!(d && (!lo || d>=lo) && (!hi || d<=hi))) return false;
      if (day !== "all" && dn !== day) return false;
      if (typ !== "ALL" && !(tp.includes("_"+typ) || tp === typ)) return false;
      return true;
    });
    return { filtered, dateField, lo, hi, useBS };
  }
  function selectedBlockSpan(){
    const start = b1Sel.value, end = bnSel.value;
    const i1 = blocks.indexOf(start), i2 = blocks.indexOf(end);
    if (i1<0 || i2<0) return [];
    const a = Math.min(i1,i2), b = Math.max(i1,i2);
    return blocks.slice(a,b+1);
  }

  // helpers
  function orderByDate(arr){ return arr.slice().sort((a,b)=> String(a[DATE]).localeCompare(String(b[DATE]))); }
  function rowsByType(type){ return rows.filter(r => String(r[TYPE]||"").toUpperCase() === type); }
  function maxDateAD(){ const ds=rows.map(r=>r[DATE]).filter(Boolean).sort(); return ds[ds.length-1] || ""; }
  function dayNameOf(iso){ const d = new Date(iso+"T00:00:00"); return d.toLocaleDateString("en-US",{weekday:"long"}); }
  function meanBlock(rowsArr, blk){ let s=0,n=0; rowsArr.forEach(r=>{ const v=num(r[blk]); if(v!==null){ s+=v;n++; }}); return n? s/n : null; }
  function avgOverBlocksOfRow(r, span){ let s=0,n=0; span.forEach(c=>{ const v=num(r[c]); if(v!==null){ s+=v;n++; }}); return n? s/n : null; }
  function meanArray(arr){ const zs=arr.filter(v=>v!=null && Number.isFinite(v)); if(!zs.length) return null; return zs.reduce((a,b)=>a+b,0)/zs.length; }

  function lastNDays(type, beforeDate, n){ const arr=orderByDate(rowsByType(type)).filter(r=>r[DATE] < beforeDate); return arr.slice(-n); }
  function prevNDaysWindow(type,beforeDate,n,offsetN){ 
    const arr=orderByDate(rowsByType(type)).filter(r=>r[DATE] < beforeDate);
    const end = arr.length - offsetN;
    const start = Math.max(0, end - n);
    return arr.slice(start, Math.max(start, end));
  }
  function pickSameWeekdaySeries(type,weekday,beforeDate,k){ 
    const arr=orderByDate(rowsByType(type)).filter(r=>r[DATE] < beforeDate && String(r[DAY]).toLowerCase()===String(weekday).toLowerCase());
    const slice = arr.slice(-k).reverse(); // most recent first
    return slice;
  }
  function windowAvg(rowsArr, blk){ if(!rowsArr || !rowsArr.length) return null; return meanBlock(rowsArr, blk); }
  function findSameDayLastYear(type, targetAD){ 
    try {
      const d=new Date(targetAD+"T00:00:00Z");
      d.setUTCFullYear(d.getUTCFullYear()-1);
      const yiso=d.toISOString().slice(0,10);
      const arr = rowsByType(type).filter(r => r[DATE] === yiso);
      return arr.length ? arr[0] : null;
    } catch(e) { return null; }
  }

  // Forecast series (unchanged math)
  function forecastSeriesForDate(targetAD, span) {
    const weekday = dayNameOf(targetAD);
    function buildForType(tp) {
      const w1 = pickSameWeekdaySeries(tp, weekday, targetAD, 1)[0];
      const w2 = pickSameWeekdaySeries(tp, weekday, targetAD, 2)[1];
      const last7   = lastNDays(tp, targetAD, 7);
      const prev7   = prevNDaysWindow(tp, targetAD, 7, 7);
      const last28  = lastNDays(tp, targetAD, 28);
      const prev28  = prevNDaysWindow(tp, targetAD, 28, 28);
      const last120 = lastNDays(tp, targetAD, 120);
      const prev120 = prevNDaysWindow(tp, targetAD, 120, 120);
      const sameLY  = findSameDayLastYear(tp, targetAD);

      return span.map(blk => {
        const wn1 = w1 ? num(w1[blk]) ?? 0 : 0;
        const wn2 = w2 ? num(w2[blk]) ?? 0 : 0;
        const last7Avg  = windowAvg(last7,  blk) ?? 0;
        const prev7Avg  = windowAvg(prev7,  blk) ?? 0;
        const last28Avg = windowAvg(last28, blk) ?? 0;
        const prev28Avg = windowAvg(prev28, blk) ?? 0;
        const last120Avg= windowAvg(last120,blk) ?? 0;
        const prev120Avg= windowAvg(prev120,blk) ?? 0;
        const lyVal     = sameLY ? (num(sameLY[blk]) ?? 0) : 0;

        let val = 0.3*wn1 + 0.2*wn2;
        val += 0.2*(wn1 + (last28Avg - prev28Avg)*0.6) + 0.3*(wn1 + (last7Avg - prev7Avg)*0.8);
        val = Math.max(0, Math.min(10000, val));
        return val;
      });
    }
    const dam = buildForType("DAM");
    const rtm = buildForType("RTM");
    const iex = dam.map((v,i)=> (v + (rtm[i]??0)) / 2);
    return { dam, rtm, iex };
  }

  // ---------- DataTable helpers ----------
  function buildAggregateRows(rowsWithStats, span) {
    const aggMin = {}, aggMax = {}, aggAvg = {};
    span.forEach(c => {
      let mn=null, mx=null, s=0, n=0;
      rowsWithStats.forEach(r => {
        const v = num(r[c]); if (v===null) return;
        if (mn===null || v<mn) mn=v; if (mx===null || v>mx) mx=v; s+=v; n+=1;
      });
      aggMin[c]=(mn===null?"":mn); aggMax[c]=(mx===null?"":mx); aggAvg[c]=(n? s/n: "");
    });
    let minOfMin=null, maxOfMax=null, sAvg=0, nAvg=0;
    rowsWithStats.forEach(r => {
      const rmin=num(r.__MIN), rmax=num(r.__MAX), ravg=num(r.__AVG);
      if (rmin!==null) minOfMin=(minOfMin===null? rmin : Math.min(minOfMin,rmin));
      if (rmax!==null) maxOfMax=(maxOfMax===null? rmax : Math.max(maxOfMax,rmax));
      if (ravg!==null){ sAvg+=ravg; nAvg+=1; }
    });
    const aggMinRow = Object.assign({}, aggMin, { _LABEL:"Aggregate-Min", __MIN:(minOfMin===null?"":minOfMin), __MAX:"", __AVG:"" });
    const aggMaxRow = Object.assign({}, aggMax, { _LABEL:"Aggregate-Max", __MIN:"", __MAX:(maxOfMax===null?"":maxOfMax), __AVG:"" });
    const aggAvgRow = Object.assign({}, aggAvg, { _LABEL:"Aggregate-Avg", __MIN:"", __MAX:"", __AVG:(nAvg? sAvg/nAvg: "") });
    return [aggMinRow, aggMaxRow, aggAvgRow];
  }

  function buildSyntheticForecastRowsForDate(targetAD, span) {
    const { dam, rtm, iex } = forecastSeriesForDate(targetAD, span);
    function mkRow(type, y) {
      const o = {}; o["_DATE"]=targetAD+" (Forecast)"; o["_NEP"]=""; o["_DAY"]=dayNameOf(targetAD); o["_TYPE"]=type;
      span.forEach((b,i)=>{ o[b]=y[i]; }); return o;
    }
    return [ mkRow("DAM",dam), mkRow("RTM",rtm), mkRow("IEX",iex) ];
  }

  // --------- Chart layout & "data levels" controls (unchanged) ---------
  function baseLayout(overrides={}) {
    return Object.assign({
      template:'plotly_white',
      margin:{l:50,r:20,t:60,b:100},
      hovermode:'x unified',
      uirevision:'keep',
      legend:{title:'Legend', font:{family:'Arial Black, Arial, sans-serif', size:12}},
      xaxis:{ title:{text:'Block / Day', font:{family:'Arial Black, Arial, sans-serif', size:14}}, tickfont:{family:'Arial Black, Arial, sans-serif', size:11}, tickangle:-90 },
      yaxis:{ title:{text:'Value', font:{family:'Arial Black, Arial, sans-serif', size:14}}, tickfont:{family:'Arial Black, Arial, sans-serif', size:11} }
    }, overrides);
  }

  function buildControls(chartId, tracesMeta, opts={}) {
    const list = document.getElementById('traces-'+chartId);
    if (list) {
      list.innerHTML = '';
      tracesMeta.forEach((t,i)=>{
        const id = `cb-${chartId}-${i}`;
        const row = document.createElement('div');
        row.className = 'inline';
        row.innerHTML = `<label for="${id}" style="flex:1; font-size:12px">${t.name || ('Series '+(i+1))}</label>
                         <input type="checkbox" id="${id}" checked>`;
        list.appendChild(row);
        row.querySelector('input').addEventListener('change', (e)=>{
          Plotly.restyle(chartId, {visible: e.target.checked ? true : 'legendonly'}, [i]);
        });
      });
    }

    const vals = document.getElementById('vals-'+chartId);
    if (vals) {
      vals.onchange = function(){
        const threshold = opts.labelsThreshold ?? Infinity;
        const maxPoints = Math.max(0, ...tracesMeta.map(t => (t.x ? t.x.length : 0)));
        const note = document.getElementById('vals-note-'+chartId);
        if (vals.checked){
          if (maxPoints >= threshold){
            vals.checked = false;
            if (note) note.textContent = `(Too many points: ${maxPoints} ≥ ${threshold}. Labels disabled)`;
            return;
          }
          const ys = tracesMeta.map(t=>t.y ?? t.z ?? null);
          Plotly.restyle(chartId, {'text': ys, 'textposition':'top center'});
          if (note) note.textContent = '';
        } else {
          Plotly.restyle(chartId, {'text': null});
        }
      };
    }
  }

  // --------- Chart 1 ---------
  function renderChartMain(filtered, span, mode) {
    // mode: 'past-only' | 'today-both' | 'future-only'
    const container = document.getElementById('chart');
    const traces = [];
    const forecastNotes = document.getElementById('forecastNotes');
    forecastNotes.textContent = "";

    function addExtremaMarkers(x, y, baseName){
      const finite = y.map((v,i)=>({v, i})).filter(o => Number.isFinite(o.v));
      if (!finite.length) return [];
      let min = finite[0], max = finite[0];
      finite.forEach(o => { if (o.v < min.v) min=o; if (o.v > max.v) max=o; });
      const mkMin = { x:[x[min.i]], y:[y[min.i]], mode:'markers', name: `${baseName} — Min`, showlegend:false, marker:{ size:10, symbol:'triangle-down', line:{width:1} } };
      const mkMax = { x:[x[max.i]], y:[y[max.i]], mode:'markers', name: `${baseName} — Max`, showlegend:false, marker:{ size:10, symbol:'star', line:{width:1} } };
      return [mkMin, mkMax];
    }

    const DATE = payload.col_names["DATE_AD"];
    const TYPE = payload.col_names["TYPE"];
    const lo = document.getElementById('firstDateAD').value;
    const hi = document.getElementById('secondDateAD').value;

    function perBlockAveragesForDate(dateISO, type) {
      const subset = rows.filter(r => r[DATE]===dateISO && String(r[TYPE]).toUpperCase()===type);
      return span.map(blk => meanBlock(subset, blk));
    }

    function addRealCurvesOverFiltered() {
      const tSel = (typeSel.value||"All").toUpperCase();
      if (tSel === "ALL") {
        const damMeans = span.map(c => { let s=0,n=0; filtered.forEach(r=>{ if((r[TYPE]||"").toUpperCase()==="DAM"){ const v=num(r[c]); if(v!==null){s+=v;n++;}}}); return n? s/n : null; });
        const rtmMeans = span.map(c => { let s=0,n=0; filtered.forEach(r=>{ if((r[TYPE]||"").toUpperCase()==="RTM"){ const v=num(r[c]); if(v!==null){s+=v;n++;}}}); return n? s/n : null; });
        const iexMeans = span.map((_,i)=>{ const d=damMeans[i], r=rtmMeans[i]; if(d==null && r==null) return null; if(d==null) return r; if(r==null) return d; return (d+r)/2; });
        traces.push({ x: span, y: damMeans, mode:'lines+markers', name:'DAM (avg)' });
        traces.push(...addExtremaMarkers(span, damMeans, 'DAM (avg)'));
        traces.push({ x: span, y: rtmMeans, mode:'lines+markers', name:'RTM (avg)' });
        traces.push(...addExtremaMarkers(span, rtmMeans, 'RTM (avg)'));
        traces.push({ x: span, y: iexMeans, mode:'lines+markers', name:'IEX (avg)' });
        traces.push(...addExtremaMarkers(span, iexMeans, 'IEX (avg)'));
      } else {
        const means = span.map(c => { let s=0,n=0; filtered.forEach(r=>{ const v=num(r[c]); if(v!==null){ s+=v;n++; }}); return n? s/n : null; });
        traces.push({ x: span, y: means, mode: 'lines+markers', name: `${tSel} (avg)` });
        traces.push(...addExtremaMarkers(span, means, `${tSel} (avg)`));
      }
    }

    if (mode === 'past-only') {
      addRealCurvesOverFiltered();
      forecastNotes.textContent = `Past selection: real curves only.`;
      Plotly.react(container, traces, baseLayout(), {responsive:true, displayModeBar:false});
      buildControls('chart', traces);
      return { syntheticRowsForTable: null, futureDates: null };
    }

    if (mode === 'future-only') {
      const days = Array.from(isoRange(lo, hi));
      const d0 = days[0] || lo;
      const fc = forecastSeriesForDate(d0, span);
      traces.push({ x: span, y: fc.dam, mode:'lines+markers', name:`DAM (Forecast ${d0})`, line:{dash:'dot'} });
      traces.push({ x: span, y: fc.rtm, mode:'lines+markers', name:`RTM (Forecast ${d0})`, line:{dash:'dot'} });
      traces.push({ x: span, y: fc.iex, mode:'lines+markers', name:`IEX (Forecast ${d0})`, line:{dash:'dashdot'} });
      forecastNotes.textContent = `Future selection: forecast curves only. IEX = (DAM+RTM)/2.`;
      Plotly.react(container, traces, baseLayout(), {responsive:true, displayModeBar:false});
      buildControls('chart', traces);
      return { syntheticRowsForTable: null, futureDates: days };
    }

    if (mode === 'today-both') {
      const fc = forecastSeriesForDate(lo, span);
      const damActual = perBlockAveragesForDate(lo, "DAM");
      const rtmActual = perBlockAveragesForDate(lo, "RTM");
      const iexActual = span.map((_,i)=>{
        const d=damActual[i], r=rtmActual[i];
        if (d==null && r==null) return null;
        return ((d??0)+(r??0))/2;
      });

      traces.push({ x: span, y: damActual, mode:'lines+markers', name:`DAM (Actual ${lo})` });
      traces.push({ x: span, y: rtmActual, mode:'lines+markers', name:`RTM (Actual ${lo})` });
      traces.push({ x: span, y: iexActual, mode:'lines+markers', name:`IEX (Actual ${lo})` });

      traces.push({ x: span, y: fc.dam, mode:'lines+markers', name:`DAM (Forecast ${lo})`, line:{dash:'dot'} });
      traces.push({ x: span, y: fc.rtm, mode:'lines+markers', name:`RTM (Forecast ${lo})`, line:{dash:'dot'} });
      traces.push({ x: span, y: fc.iex, mode:'lines+markers', name:`IEX (Forecast ${lo})`, line:{dash:'dashdot'} });

      forecastNotes.textContent = `Today selected (${lo}). Showing actual (solid) and forecast (dotted). IEX = (DAM+RTM)/2.`;
      Plotly.react(container, traces, baseLayout(), {responsive:true, displayModeBar:false});
      buildControls('chart', traces);
      return { syntheticRowsForTable: null, futureDates: null };
    }
  }

  // --------- Chart 2 (unchanged) ---------
  function renderChart2(filtered, span, dateField) {
    const card = document.getElementById('card2');
    const el = document.getElementById('chart2');
    const tSel = (typeSel.value||"All").toUpperCase();

    const useBS = (dateField === NEP);
    const lo = useBS ? fBS.value : fAD.value;
    const hi = useBS ? sBS.value : sAD.value;
    const singleRange = (lo && hi && lo===hi);
    if (singleRange || tSel!=="ALL") { card.style.display = "none"; return; }

    const byDate = new Map();
    filtered.forEach(r => { const key = r[dateField]; if (!byDate.has(key)) byDate.set(key, []); byDate.get(key).push(r); });
    const dates = Array.from(byDate.keys()).sort();
    const dam=[], rtm=[], iex=[];
    dates.forEach(key => {
      const bucket = byDate.get(key);
      const damRows = bucket.filter(x => String(x[TYPE]).toUpperCase()==="DAM");
      const rtmRows = bucket.filter(x => String(x[TYPE]).toUpperCase()==="RTM");
      const dAvg = damRows.length ? meanArray(damRows.map(r => avgOverBlocksOfRow(r, span))) : null;
      const rAvg = rtmRows.length ? meanArray(rtmRows.map(r => avgOverBlocksOfRow(r, span))) : null;
      dam.push(dAvg); rtm.push(rAvg); iex.push((dAvg==null && rAvg==null)? null : ((dAvg??0)+(rAvg??0))/2);
    });

    const isAD = (dateField === DATE);
    const traces = [
      { x: dates, y: dam, mode:'lines+markers', name:'DAM (block-avg)' },
      { x: dates, y: rtm, mode:'lines+markers', name:'RTM (block-avg)' },
      { x: dates, y: iex, mode:'lines+markers', name:'IEX (block-avg)' },
    ];
    const layout = baseLayout(Object.assign(
      { title: "Day-series (block-averaged)" },
      isAD ? { xaxis:{type:'date', tickangle:-90, rangeslider:{visible:true}, title:{text:'Date (AD)', font:{family:'Arial Black, Arial, sans-serif', size:14}}, tickfont:{family:'Arial Black, Arial, sans-serif', size:11}} 
           : { xaxis:{type:'category', tickangle:-90, title:{text:'Nepali Date', font:{family:'Arial Black, Arial, sans-serif', size:14}}, tickfont:{family:'Arial Black, Arial, sans-serif', size:11}} }
    ));
    card.style.display = "";
    Plotly.react(el, traces, layout, {responsive:true, displayModeBar:false});
    buildControls('chart2', traces, { labelsThreshold: 100 });
  }

  // --------- Chart 3 (UPDATED per your request) ---------
  function renderChart3(filtered, span, hide) {
    const card = document.getElementById('card3');
    const el = document.getElementById('chart3');
    const titleEl = document.getElementById('chart3Title');
    if (hide) { card.style.display = "none"; return; }

    const selectedDay = (daySel.value || "All");
    const tSel = (typeSel.value||"All").toUpperCase();

    const DATE = payload.col_names["DATE_AD"];
    const TYPE = payload.col_names["TYPE"];
    const DAY  = payload.col_names["DAY"];

    // When Day_Name is a particular day → block-wise price plots (multiple lines) for all days in range
    if (selectedDay !== "All") {
      // Build list of dates present in filtered set (already restricted to that weekday)
      const dates = Array.from(new Set(filtered.map(r => r[DATE]).filter(Boolean))).sort();
      const traces = [];

      // Helper to compute block-wise averages for a date and type
      function yFor(dateISO, type) {
        if (type === "IEX") {
          const damRows = filtered.filter(r => r[DATE]===dateISO && String(r[TYPE]).toUpperCase()==="DAM");
          const rtmRows = filtered.filter(r => r[DATE]===dateISO && String(r[TYPE]).toUpperCase()==="RTM");
          return span.map(blk => {
            const dAvg = damRows.length ? meanBlock(damRows, blk) : null;
            const rAvg = rtmRows.length ? meanBlock(rtmRows, blk) : null;
            if (dAvg==null && rAvg==null) return null;
            return ((dAvg??0)+(rAvg??0))/2;
          });
        } else {
          const rowsThis = filtered.filter(r => r[DATE]===dateISO && String(r[TYPE]).toUpperCase()===type);
          return span.map(blk => meanBlock(rowsThis, blk));
        }
      }

      // Decide which series to show based on Type selection
      const seriesToShow = (tSel === "ALL") ? ["DAM","RTM","IEX"] : [tSel];
      seriesToShow.forEach(tp => {
        dates.forEach(dISO => {
          const y = yFor(dISO, tp);
          traces.push({ x: span, y, mode:'lines+markers', name:`${tp} — ${dISO}` });
        });
      });

      titleEl.textContent = `Chart 3 — ${selectedDay}: Block-wise real values (lines per date)`;
      card.style.display = "";
      Plotly.react(el, traces, baseLayout(), {responsive:true, displayModeBar:false});
      buildControls('chart3', traces, { labelsThreshold: 100 });
      return;
    }

    // Otherwise (Day_Name = All) → original weekday bars behavior
    const useBS = modeAD.checked ? false : true; // unchanged behavior path
    const lo = (useBS ? fBS.value : fAD.value) || "";
    const hi = (useBS ? sBS.value : sAD.value) || "";
    const singleRange = (lo && hi && lo===hi);

    let categories = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
    if (singleRange && filtered.length) categories = [ String(filtered[0][DAY]) ];

    const byW = new Map(categories.map(w => [w, []]));
    filtered.forEach(r => { if (byW.has(r[DAY])) byW.get(r[DAY]).push(r); });

    function avgOverBlocksOfRow(r, span){ let s=0,n=0; span.forEach(c=>{ const v=num(r[c]); if(v!==null){ s+=v;n++; }}); return n? s/n : null; }
    function meanArray(arr){ const zs=arr.filter(v=>v!=null && Number.isFinite(v)); if(!zs.length) return null; return zs.reduce((a,b)=>a+b,0)/zs.length; }
    function aggForType(w, type) {
      const arr = (byW.get(w)||[]).filter(r => String(r[TYPE]).toUpperCase()===type);
      if (!arr.length) return null;
      return meanArray(arr.map(r => avgOverBlocksOfRow(r, span)));
    }

    // Respect Type selection for bar chart: if DAM or RTM, show that only; if All, show all 3 (with IEX derived)
    let traces = [];
    if (tSel === "DAM" || tSel === "RTM") {
      const y = categories.map(w => aggForType(w, tSel));
      traces = [{ x: categories, y, type:'bar', name: `${tSel} (block-avg)` }];
    } else {
      let dam = categories.map(w => aggForType(w,"DAM"));
      let rtm = categories.map(w => aggForType(w,"RTM"));
      let iex = categories.map((_,i)=>{ const d=dam[i], r=rtm[i]; if(d==null && r==null) return null; return ((d??0)+(r??0))/2; });
      traces = [
        { x: categories, y: dam, type:'bar', name:'DAM (block-avg)' },
        { x: categories, y: rtm, type:'bar', name:'RTM (block-avg)' },
        { x: categories, y: iex, type:'bar', name:'IEX (block-avg)' },
      ];
    }

    titleEl.textContent = singleRange ? `Only ${categories[0]} — Weekday average` : "Weekday averages (block-averaged)";
    card.style.display = "";
    Plotly.react(el, traces, baseLayout({ barmode:'group' }), {responsive:true, displayModeBar:false});
    buildControls('chart3', traces);
  }

  // ---------- Table ----------
  function renderTable(filtered, span, syntheticRows, futureDatesForTable) {
    const rowsForTable = filtered.slice();
    if (syntheticRows && syntheticRows.length) rowsForTable.push(...syntheticRows);
    if (futureDatesForTable && futureDatesForTable.length) {
      rowsForTable.length = 0; // forecast-only table for future ranges
      futureDatesForTable.forEach(dISO => rowsForTable.push(...buildSyntheticForecastRowsForDate(dISO, span)));
    }

    const rowsWithStats = rowsForTable.map(r => {
      let mn=null, mx=null, s=0, n=0;
      span.forEach(c => { const v = num(r[c]); if (v===null) return; if (mn===null||v<mn) mn=v; if (mx===null||v>mx) mx=v; s+=v; n+=1; });
      const st = { min:(mn===null?"":mn), max:(mx===null?"":mx), avg:(n? s/n: "") };
      const lbl = r["_DATE"] ? r["_DATE"] : "";
      return Object.assign({}, r, { __MIN: st.min, __MAX: st.max, __AVG: st.avg, _LABEL: lbl });
    });

    const aggRows = buildAggregateRows(rowsWithStats, span);

    const hasNepali = !!rowsForTable.find(r => r._NEP);
    const cols = [];
    cols.push({title: 'DATE', data: '_LABEL'});
    if (hasNepali) cols.push({title: 'Nepali_Date', data: '_NEP'});
    cols.push({title: 'Day Name', data: '_DAY'});
    cols.push({title: 'Date_Type', data: '_TYPE'});
    span.forEach(c => cols.push({title: c, data: c}));
    cols.push({title: 'Min', data: '__MIN'});
    cols.push({title: 'Max', data: '__MAX'});
    cols.push({title: 'Avg', data: '__AVG'});

    const tableData = rowsWithStats.concat(aggRows);

    const elId = 'dataTable';
    const wrap = document.getElementById('tableWrap');
    wrap.innerHTML = `<table id="${elId}" class="display compact nowrap" style="width:100%"></table>`;

    if (window.dt) { try { window.dt.destroy(); } catch(e) {} window.dt = null; }

    window.dt = new $.fn.dataTable.Api($('#'+elId).DataTable({
      data: tableData,
      columns: cols,
      paging: true, searching: true, ordering: true,
      scrollY: '420px', scrollX: true, deferRender: true, scroller: true,
      createdRow: function(row, data) {
        const label = data._LABEL || '';
        if (/\(Forecast\)$/.test(label)) $(row).css({'background':'#fff9ee'});
        if (label==='Aggregate-Min' || label==='Aggregate-Max' || label==='Aggregate-Avg') {
          $(row).css({'font-weight':'600','border-top':'2px solid #999'});
        }
      },
      columnDefs: [{
        targets: '_all',
        render: function(data, type) {
          if (data === "" || data === null || data === undefined) return "";
          if (type === 'display' && !isNaN(Number(data))) {
            const n = Number(data); return Number.isFinite(n) ? n.toLocaleString() : data;
          }
          return data;
        }
      }]
    })));

    // Download CSV of current table view
    document.getElementById('downloadCsvBtn').onclick = function(){
      const api = window.dt;
      const rows = api.rows({search:'applied'}).data().toArray();
      const headers = cols.map(c=>c.title);
      const out = rows.map(r=>{
        const obj = {};
        cols.forEach(c=>{
          const key = c.data;
          obj[c.title] = r[key] ?? "";
        });
        return obj;
      });
      const csv = toCSV(out, headers);
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'summary_table.csv';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };
  }

  function update() {
    const { filtered, dateField, lo, hi } = filterRowsBase();
    const span = selectedBlockSpan();
    $('#rowCount').text(`Rows: ${filtered.length}`);

    // Decide display mode (AD only; BS unchanged)
    const isAD = (dateField === DATE);
    let mode = 'past-only';
    let futureDatesForTable = null;

    if (isAD && lo && hi) {
      const today = todayISO();
      const isSingle = (lo === hi);
      if (isSingle && lo === today) {
        mode = 'today-both';
      } else if (hi < today) {
        mode = 'past-only';
      } else if (lo > today) {
        mode = 'future-only';
        futureDatesForTable = Array.from(isoRange(lo, hi));
      } else {
        mode = 'past-only'; // mixed -> real only
      }
    }

    const main = renderChartMain(filtered, span, mode) || {};
    renderTable(filtered, span, main.syntheticRowsForTable || null, futureDatesForTable);

    // Chart-2: only for non-single ranges
    const singleRange = (lo && hi && lo===hi);
    if (!singleRange) renderChart2(filtered, span, dateField); else document.getElementById('card2').style.display = "none";

    // Chart-3 visibility: hide for future; show for today & past
    const hideC3 = (mode === 'future-only');
    renderChart3(filtered, span, hideC3);
  }

  // Initial render + bind
  update();
  document.getElementById('generateBtn').addEventListener('click', update);
})();
</script>

</body>
</html>
